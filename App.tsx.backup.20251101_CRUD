// üöö DeliveryApp Mobile - KEYBOARD ISSUE FIXED
// Copy this file as App.tsx to your DeliveryAppMobile directory
// FIXES: Virtual keyboard blocking bottom form fields

/**
 * DEPLOYMENT INSTRUCTIONS:
 * 1. Copy this entire file content
 * 2. Paste it as App.tsx in your DeliveryAppMobile directory  
 * 3. Restart Expo server: npx expo start --port 19000
 * 4. Test customer registration on phone - keyboard should no longer block fields
 */

import * as Network from 'expo-network';
import React, { useEffect, useState } from 'react';
import {
  ActivityIndicator,
  Alert,
  Button,
  KeyboardAvoidingView, Platform, ScrollView,
  StyleSheet,
  Switch,
  Text,
  TextInput,
  View
} from 'react-native';

// ========================================
// CUSTOMER DELIVERY HISTORY COMPONENT
// ========================================
const CustomerDeliveryHistory = ({ customerId }: { customerId: any }) => {
  const [deliveryHistory, setDeliveryHistory] = React.useState([]);
  const [loading, setLoading] = React.useState(true);

  React.useEffect(() => {
    loadCustomerDeliveries();
  }, [customerId]);

  const loadCustomerDeliveries = async () => {
    try {
      // This would be implemented in the main component's functions
      // For now, filter from existing deliveries
      setLoading(false);
    } catch (error) {
      console.error('Error loading customer deliveries:', error);
      setLoading(false);
    }
  };

  if (loading) {
    return (
      <View style={styles.detailCard}>
        <Text style={styles.detailCardTitle}>Delivery History</Text>
        <Text style={styles.emptyText}>Loading deliveries...</Text>
      </View>
    );
  }

  return (
    <View style={styles.detailCard}>
      <Text style={styles.detailCardTitle}>Delivery History</Text>
      {deliveryHistory.length === 0 ? (
        <Text style={styles.emptyText}>No deliveries found for this customer</Text>
      ) : (
        deliveryHistory.map((delivery: any, index: number) => (
          <View key={index} style={styles.deliveryItem}>
            <Text style={styles.deliveryTitle}>Delivery #{delivery.id}</Text>
            <Text style={styles.deliveryDetail}>üìç From: {delivery.pickup_location}</Text>
            <Text style={styles.deliveryDetail}>üìç To: {delivery.dropoff_location}</Text>
            <Text style={styles.deliveryDetail}>üìä Status: {delivery.status}</Text>
            <Text style={styles.deliveryDetail}>üìÖ Date: {delivery.created_at ? new Date(delivery.created_at).toLocaleDateString() : 'N/A'}</Text>
          </View>
        ))
      )}
    </View>
  );
};

export default function App() {
  // ====== STUBS FOR MISSING SCREENS ======
  function AdminCustomersScreen({
    onBack,
    customers,
    loadCustomers
  }: {
    onBack: () => void,
    customers: any[],
    loadCustomers: () => Promise<void>
  }) {
    const [mode, setMode] = useState<'list' | 'create' | 'edit' | 'detail'>('list');
    const [selected, setSelected] = useState<any>(null);
    const [form, setForm] = useState<any>({
      username: '', email: '', password: '', first_name: '', last_name: '', phone_number: '',
      address_unit: '', address_street: '', address_city: '', address_state: '', address_postal_code: '',
      company_name: '', is_business: false, preferred_pickup_address: ''
    });
    const [error, setError] = useState<string | null>(null);
    const [localLoading, setLocalLoading] = useState(false);

    // Handlers
    const handleSelect = (customer: any) => {
      setSelected(customer);
      setMode('detail');
    };
    const handleEdit = (customer: any) => {
      setSelected(customer);
      setForm({
        username: customer.username || '',
        email: customer.email || '',
        password: '',
        first_name: customer.first_name || '',
        last_name: customer.last_name || '',
        phone_number: customer.phone_number || '',
        address_unit: customer.address_unit || '',
        address_street: customer.address_street || '',
        address_city: customer.address_city || '',
        address_state: customer.address_state || '',
        address_postal_code: customer.address_postal_code || '',
        company_name: customer.company_name || '',
        is_business: customer.is_business || false,
        preferred_pickup_address: customer.preferred_pickup_address || ''
      });
      setMode('edit');
    };
    const handleDelete = async (customer: any) => {
      Alert.alert('Confirm Delete', 'Are you sure you want to delete this customer?', [
        { text: 'Cancel', style: 'cancel' },
        {
          text: 'Delete', style: 'destructive', onPress: async () => {
            setLocalLoading(true);
            try {
              await deleteCustomer(customer.id);
              setMode('list');
              setSelected(null);
              await loadCustomers();
            } catch (e) {
              setError('Failed to delete customer');
            }
            setLocalLoading(false);
          }
        }
      ]);
    };
    const handleCreate = async () => {
      setLocalLoading(true);
      setError(null);
      try {
        await createCustomer(form);
        setMode('list');
        setForm({
          username: '', email: '', password: '', first_name: '', last_name: '', phone_number: '',
          address_unit: '', address_street: '', address_city: '', address_state: '', address_postal_code: '',
          company_name: '', is_business: false, preferred_pickup_address: ''
        });
        await loadCustomers();
      } catch (e) {
        setError('Failed to create customer');
      }
      setLocalLoading(false);
    };
    const handleUpdate = async () => {
      if (!selected) return;
      setLocalLoading(true);
      setError(null);
      try {
        await updateCustomer(selected.id, form);
        setMode('list');
        setSelected(null);
        await loadCustomers();
      } catch (e) {
        setError('Failed to update customer');
      }
      setLocalLoading(false);
    };

    // Render
    if (mode === 'list') {
      return (
        <ScrollView style={styles.container}>
          <View style={styles.content}>
            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 10 }}>
              <Button title="‚Üê Back" onPress={onBack} />
              <Text style={[styles.title, { flex: 1, textAlign: 'center' }]}>üë• Admin Customers</Text>
            </View>
            {error && <Text style={{ color: 'red', marginBottom: 10 }}>{error}</Text>}
            <View style={styles.buttonContainer}>
              <Button title="Add Customer" onPress={() => { setMode('create'); setForm({ username: '', email: '', password: '', first_name: '', last_name: '', phone_number: '', address_unit: '', address_street: '', address_city: '', address_state: '', address_postal_code: '', company_name: '', is_business: false, preferred_pickup_address: '' }); }} />
            </View>
            {localLoading ? <ActivityIndicator /> : customers.length === 0 ? (
              <Text style={styles.emptyText}>No customers found.</Text>
            ) : (
              customers.map((customer: any) => (
                <View key={customer.id} style={styles.itemContainer}>
                  <Text style={styles.itemTitle}>{customer.first_name} {customer.last_name} ({customer.username})</Text>
                  <Text>Email: {customer.email}</Text>
                  <Text>Phone: {customer.phone_number}</Text>
                  <View style={{ flexDirection: 'row', marginTop: 8 }}>
                    <View style={{ flex: 1, marginRight: 4 }}>
                      <Button title="Detail" onPress={() => handleSelect(customer)} />
                    </View>
                    <View style={{ flex: 1, marginRight: 4 }}>
                      <Button title="Edit" onPress={() => handleEdit(customer)} />
                    </View>
                    <View style={{ flex: 1 }}>
                      <Button title="Delete" color="#d9534f" onPress={() => handleDelete(customer)} />
                    </View>
                  </View>
                </View>
              ))
            )}
          </View>
        </ScrollView>
      );
    }
    if (mode === 'create' || mode === 'edit') {
      return (
        <ScrollView style={styles.container}>
          <View style={styles.content}>
            <Text style={styles.title}>{mode === 'create' ? 'Add Customer' : 'Edit Customer'}</Text>
            {error && <Text style={{ color: 'red', marginBottom: 10 }}>{error}</Text>}
            <TextInput style={styles.input} value={form.username} onChangeText={t => setForm((f: typeof form) => ({ ...f, username: t }))} placeholder="Username *" autoCapitalize="none" />
            <TextInput style={styles.input} value={form.email} onChangeText={t => setForm((f: typeof form) => ({ ...f, email: t }))} placeholder="Email *" autoCapitalize="none" keyboardType="email-address" />
            <TextInput style={styles.input} value={form.password} onChangeText={t => setForm((f: typeof form) => ({ ...f, password: t }))} placeholder="Password *" secureTextEntry />
            <TextInput style={styles.input} value={form.first_name} onChangeText={t => setForm((f: typeof form) => ({ ...f, first_name: t }))} placeholder="First Name" />
            <TextInput style={styles.input} value={form.last_name} onChangeText={t => setForm((f: typeof form) => ({ ...f, last_name: t }))} placeholder="Last Name" />
            <TextInput style={styles.input} value={form.phone_number} onChangeText={t => setForm((f: typeof form) => ({ ...f, phone_number: t }))} placeholder="Phone Number" keyboardType="phone-pad" />
            <TextInput style={styles.input} value={form.address_unit} onChangeText={t => setForm((f: typeof form) => ({ ...f, address_unit: t }))} placeholder="Unit/Apartment" />
            <TextInput style={styles.input} value={form.address_street} onChangeText={t => setForm((f: typeof form) => ({ ...f, address_street: t }))} placeholder="Street Address" />
            <TextInput style={styles.input} value={form.address_city} onChangeText={t => setForm((f: typeof form) => ({ ...f, address_city: t }))} placeholder="City" />
            <TextInput style={styles.input} value={form.address_state} onChangeText={t => setForm((f: typeof form) => ({ ...f, address_state: t }))} placeholder="State/Province" />
            <TextInput style={styles.input} value={form.address_postal_code} onChangeText={t => setForm((f: typeof form) => ({ ...f, address_postal_code: t }))} placeholder="Postal/ZIP Code" />
            <View style={styles.switchContainer}>
              <Text style={styles.switchLabel}>Is Business Customer</Text>
              <Switch value={form.is_business} onValueChange={v => setForm((f: typeof form) => ({ ...f, is_business: v }))} />
            </View>
            {form.is_business && (
              <TextInput style={styles.input} value={form.company_name} onChangeText={t => setForm((f: typeof form) => ({ ...f, company_name: t }))} placeholder="Company Name" />
            )}
            <TextInput style={[styles.input, styles.multilineInput]} value={form.preferred_pickup_address} onChangeText={t => setForm((f: typeof form) => ({ ...f, preferred_pickup_address: t }))} placeholder="Preferred Pickup Address" multiline numberOfLines={2} />
            <View style={styles.buttonContainer}>
              <Button title={mode === 'create' ? 'Create' : 'Update'} onPress={mode === 'create' ? handleCreate : handleUpdate} disabled={localLoading} />
            </View>
            <View style={styles.buttonContainer}>
              <Button title="Cancel" onPress={() => { setMode('list'); setSelected(null); }} />
            </View>
          </View>
        </ScrollView>
      );
    }
    if (mode === 'detail' && selected) {
      return (
        <ScrollView style={styles.container}>
          <View style={styles.content}>
            <Text style={styles.title}>Customer Detail</Text>
            <Text style={styles.itemTitle}>{selected.first_name} {selected.last_name} ({selected.username})</Text>
            <Text>Email: {selected.email}</Text>
            <Text>Phone: {selected.phone_number}</Text>
            <Text>Business: {selected.is_business ? 'Yes' : 'No'}</Text>
            {selected.is_business && <Text>Company: {selected.company_name}</Text>}
            <Text>Address: {selected.address_unit} {selected.address_street}, {selected.address_city}, {selected.address_state} {selected.address_postal_code}</Text>
            <Text>Preferred Pickup: {selected.preferred_pickup_address}</Text>
            <View style={styles.buttonContainer}>
              <Button title="Edit" onPress={() => handleEdit(selected)} />
            </View>
            <View style={styles.buttonContainer}>
              <Button title="Delete" color="#d9534f" onPress={() => handleDelete(selected)} />
            </View>
            <View style={styles.buttonContainer}>
              <Button title="Back to List" onPress={() => { setMode('list'); setSelected(null); }} />
            </View>
          </View>
        </ScrollView>
      );
    }
    // fallback
    return (
      <View style={styles.container}><Text>Invalid state</Text></View>
    );
  }

  function AdminVehiclesScreen({ onBack }: { onBack: () => void }) {
    return (
      <View style={styles.container}>
        <View style={styles.content}>
          <Text style={styles.title}>üöõ Admin Vehicles</Text>
          <Text style={styles.infoText}>This screen is not yet implemented.</Text>
          <View style={styles.buttonContainer}>
            <Button title="Back" onPress={onBack} />
          </View>
        </View>
      </View>
    );
  }

  function AdminDeliveriesScreen({ onBack }: { onBack: () => void }) {
    return (
      <View style={styles.container}>
        <View style={styles.content}>
          <Text style={styles.title}>üì¶ Admin Deliveries</Text>
          <Text style={styles.infoText}>This screen is not yet implemented.</Text>
          <View style={styles.buttonContainer}>
            <Button title="Back" onPress={onBack} />
          </View>
        </View>
      </View>
    );
  }

  function DeliveryRequestScreen({ onBack }: { onBack: () => void }) {
    return (
      <View style={styles.container}>
        <View style={styles.content}>
          <Text style={styles.title}>üìã Delivery Request</Text>
          <Text style={styles.infoText}>This screen is not yet implemented.</Text>
          <View style={styles.buttonContainer}>
            <Button title="Back" onPress={onBack} />
          </View>
        </View>
      </View>
    );
  }

  function MyDeliveriesScreen({ onBack }: { onBack: () => void }) {
    return (
      <View style={styles.container}>
        <View style={styles.content}>
          <Text style={styles.title}>üìã My Deliveries</Text>
          <Text style={styles.infoText}>This screen is not yet implemented.</Text>
          <View style={styles.buttonContainer}>
            <Button title="Back" onPress={onBack} />
          </View>
        </View>
      </View>
    );
  }
  // All constants, useState, useEffect, and helper functions at the top
  // Dynamically detect local IP for API_BASE
  const [API_BASE, setApiBase] = useState('http://localhost:8081');
  const [currentNetwork, setCurrentNetwork] = useState('Detecting...');
  useEffect(() => {
    // Only try to detect on real device, not web
    if (Platform.OS !== 'web') {
      (async () => {
        try {
          const ip = await Network.getIpAddressAsync();
          if (ip && ip.startsWith('192.168.')) {
            setApiBase(`http://${ip}:8081`);
            setCurrentNetwork(`Auto-detected (${ip})`);
          }
        } catch (e) {
          console.log('Failed to get IP address:', e);
        }
      })();
    }
  }, []);
  // Optionally, you can keep fallback endpoints for manual override
  const NETWORK_ENDPOINTS = [
    { url: API_BASE, name: 'Auto-detected' },
    { url: 'http://192.168.1.77:8081', name: 'Current Mobile Network' },
    { url: 'http://192.168.1.85:8081', name: 'Home Office Network' },
    { url: 'http://192.168.1.87:8081', name: 'Home Office Network (Alt)' },
    { url: 'http://172.20.10.6:8081', name: 'Mobile Hotspot' }
  ];
  const [currentScreen, setCurrentScreen] = useState('main');
  const [backendStatus, setBackendStatus] = useState('Checking...');
  const [loading, setLoading] = useState(false);
  const [authToken, setAuthToken] = useState(null);
  const [userType, setUserType] = useState<'admin' | 'customer' | 'driver' | null>(null); // 'admin', 'customer', 'driver'
  const [driverCrudMode, setDriverCrudMode] = useState<'list' | 'create' | 'edit'>('list');
  const [selectedDriver, setSelectedDriver] = useState<any>(null);
  const [driverFormState, setDriverFormState] = useState<any>({ name: '', phone_number: '', license_number: '' });
  const [crudMode, setCrudMode] = useState('list'); // 'list', 'create', 'edit', 'delete', 'detail'
  const [selectedCustomer, setSelectedCustomer] = useState<any>(null);
  const [vehicleCrudMode, setVehicleCrudMode] = useState('list'); // 'list', 'create', 'edit', 'delete', 'detail
  const [selectedVehicle, setSelectedVehicle] = useState(null);
  const [deliveries, setDeliveries] = useState<any[]>([]);
  const [customers, setCustomers] = useState<any[]>([]);
  const [drivers, setDrivers] = useState<any[]>([]);
  const [vehicles, setVehicles] = useState<any[]>([]);
  const [assignments, setAssignments] = useState<any[]>([]);
  const [driverVehicles, setDriverVehicles] = useState<any[]>([]);
  const [adminScreen, setAdminScreen] = useState<string | null>(null); // e.g. 'driver_vehicles'

  // Form states
  const [customerForm, setCustomerForm] = useState({
    username: '',
    email: '',
    password: '',
    first_name: '',
    last_name: '',
    phone_number: '',
    address: '', // Keep legacy field for backward compatibility
    address_unit: '',
    address_street: '',
    address_city: '',
    address_state: '',
    address_postal_code: '',
    address_country: '',
    company_name: '',
    is_business: false,
    preferred_pickup_address: ''
  });

  const [driverForm, setDriverForm] = useState({
    username: '',
    email: '',
    password: '',
    first_name: '',
    last_name: '',
    phone_number: '',
    license_number: '',
    vehicle_license_plate: '',
    vehicle_make: '',
    vehicle_model: '',
    year: new Date().getFullYear(),
    vehicle_vin: '',
    vehicle_capacity: 1000
  });

  const [vehicleForm, setVehicleForm] = useState({
    license_plate: '',
    make: '',
    model: '',
    year: new Date().getFullYear(),
    vin: '',
    capacity: 1000,
    capacity_unit: 'kg'
  });

  const [deliveryForm, setDeliveryForm] = useState({
    pickup_location: '',
    dropoff_location: '',
    item_description: '',
    same_pickup_as_customer: false,
    use_preferred_pickup: false
  });

  const [loginForm, setLoginForm] = useState({
    username: '',
    password: ''
  });

  // ========================================
  // NETWORK & BACKEND FUNCTIONS
  // ========================================

  const checkBackend = async () => {
    for (const endpoint of NETWORK_ENDPOINTS) {
      try {
        const response = await fetch(`${endpoint.url}/api/`, {
          method: 'GET',

        });

        if (response.status === 401 || response.status === 200) {
          setApiBase(endpoint.url);
          setCurrentNetwork(endpoint.name);
          setBackendStatus('‚úÖ Connected');
          return;
        }
      } catch (error) {
        console.log(`Failed to connect to ${endpoint.name}`);
      }
    }

    setBackendStatus('‚ùå No Backend Found');
    setCurrentNetwork('Not Connected');
  };

  // ========================================
  // API FUNCTIONS
  // ========================================

  const makeAuthenticatedRequest = async (endpoint: string, options: Record<string, any> = {}) => {
    const headers: any = {
      'Content-Type': 'application/json',
      ...((typeof authToken === 'string' && authToken) ? { 'Authorization': `Bearer ${authToken}` } : {}),
      ...(options.headers || {})
    };

    return fetch(`${API_BASE}${endpoint}`, {
      ...options,
      headers
    });
  };

  // Authentication Functions
  const login = async () => {
    if (!loginForm.username || !loginForm.password) {
      Alert.alert('Error', 'Please fill in all required fields');
      return;
    }

    setLoading(true);
    try {
      const response = await fetch(`${API_BASE}/api/token/`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(loginForm)
      });

      if (response.ok) {
        const data = await response.json();
        setAuthToken(data.access);

        // Determine user type by checking available endpoints
        await determineUserType(data.access);

        setCurrentScreen('dashboard');
        setLoginForm({ username: '', password: '' });
        Alert.alert('Success', 'Logged in successfully!');
      } else {
        const errorData = await response.json();
        Alert.alert('Login Failed', errorData.detail || 'Invalid credentials');
      }
    } catch (error) {
      Alert.alert('Error', 'Network error during login');
    }
    setLoading(false);
  };

  const determineUserType = async (token: string) => {
    // Try customer profile first
    try {
      const customerResponse = await fetch(`${API_BASE}/api/customers/me/`, {
        headers: { 'Authorization': `Bearer ${token}` }
      });
      if (customerResponse.ok) {
        setUserType('customer');
        return;
      }
    } catch (error) {
      console.log('Not a customer user');
    }

    // Default to admin if customer check fails
    setUserType('admin');
  };

  // Registration Functions
  const registerCustomer = async () => {
    if (!customerForm.username || !customerForm.email || !customerForm.password) {
      Alert.alert('Error', 'Please fill in all required fields (*, username, email, password)');
      return;
    }

    setLoading(true);
    try {
      const response = await fetch(`${API_BASE}/api/customers/register/`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(customerForm)
      });

      if (response.ok) {
        Alert.alert('Success', 'Customer registered successfully! You can now login.');
        setCustomerForm({
          username: '', email: '', password: '', first_name: '', last_name: '',
          phone_number: '', address: '', address_unit: '', address_street: '',
          address_city: '', address_state: '', address_postal_code: '',
          address_country: 'US',
          company_name: '', is_business: false,
          preferred_pickup_address: ''
        });
        setCurrentScreen('login');
      } else {
        const errorData = await response.json();
        Alert.alert('Registration Failed', JSON.stringify(errorData));
      }
    } catch (error) {
      Alert.alert('Error', 'Network error during registration');
    }
    setLoading(false);
  };

  const registerDriver = async () => {
    // Validate required fields
    if (!driverForm.username || !driverForm.email || !driverForm.password ||
      !driverForm.first_name || !driverForm.last_name || !driverForm.phone_number || !driverForm.license_number ||
      !driverForm.vehicle_license_plate || !driverForm.vehicle_make || !driverForm.vehicle_model ||
      !driverForm.year || !driverForm.vehicle_vin) {
      Alert.alert('Error', 'Please fill in all required fields');
      return;
    }

    setLoading(true);
    try {
      // Combine first and last name for the API
      const registrationData = {
        ...driverForm,
        year: driverForm.year ? Number(driverForm.year) : new Date().getFullYear(),
        name: `${driverForm.first_name} ${driverForm.last_name}`
      };

      const response = await fetch(`${API_BASE}/api/drivers/register/`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(registrationData)
      });

      if (response.ok) {
        Alert.alert('Success', 'Driver registered successfully! You can now login.');
        setDriverForm({
          username: '', email: '', password: '', first_name: '', last_name: '', phone_number: '',
          license_number: '', vehicle_license_plate: '', vehicle_make: '', vehicle_model: '',
          year: new Date().getFullYear(), vehicle_vin: '', vehicle_capacity: 1000
        });
        setCurrentScreen('login');
      } else {
        const errorData = await response.json();
        Alert.alert('Registration Failed', JSON.stringify(errorData));
      }
    } catch (error) {
      Alert.alert('Error', 'Network error during driver registration');
    }
    setLoading(false);
  };

  // Data Loading Functions
  const loadData = async () => {
    if (!authToken) return;

    setLoading(true);
    try {
      // Load all data based on user type
      if (userType === 'admin' || userType === 'driver') {
        await Promise.all([
          loadDeliveries(),
          loadCustomers(),
          loadDrivers(),
          loadVehicles(),
          loadAssignments(),
          loadDriverVehicles()
        ]);
      } else if (userType === 'customer') {
        await loadMyDeliveries();
      }
    } catch (error) {
      console.error('Error loading data:', error);
    }
    setLoading(false);
  };

  const loadDeliveries = async () => {
    try {
      const response = await makeAuthenticatedRequest('/api/deliveries/');
      if (response.ok) {
        const data = await response.json();
        setDeliveries(data.results || data);
      }
    } catch (error) {
      console.error('Error loading deliveries:', error);
    }
  };

  const loadMyDeliveries = async () => {
    try {
      const response = await makeAuthenticatedRequest('/api/customers/my_deliveries/');
      if (response.ok) {
        const data = await response.json();
        setDeliveries(data.results || data);
      }
    } catch (error) {
      console.error('Error loading my deliveries:', error);
    }
  };

  const loadCustomers = async () => {
    try {
      const response = await makeAuthenticatedRequest('/api/customers/');
      if (response.ok) {
        const data = await response.json();
        setCustomers(data.results || data);
      }
    } catch (error) {
      console.error('Error loading customers:', error);
    }
  };

  const loadDrivers = async () => {
    try {
      const response = await makeAuthenticatedRequest('/api/drivers/');
      if (response.ok) {
        const data = await response.json();
        setDrivers(data.results || data);
      }
    } catch (error) {
      console.error('Error loading drivers:', error);
    }
  };

  const loadVehicles = async () => {
    try {
      const response = await makeAuthenticatedRequest('/api/vehicles/');
      if (response.ok) {
        const data = await response.json();
        setVehicles(data.results || data);
      }
    } catch (error) {
      console.error('Error loading vehicles:', error);
    }
  };

  const loadAssignments = async () => {
    try {
      const response = await makeAuthenticatedRequest('/api/assignments/');
      if (response.ok) {
        const data = await response.json();
        setAssignments(data.results || data);
      }
    } catch (error) {
      console.error('Error loading assignments:', error);
    }
  };

  const loadDriverVehicles = async () => {
    try {
      const response = await makeAuthenticatedRequest('/api/driver-vehicles/');
      if (response.ok) {
        const data = await response.json();
        setDriverVehicles(data.results || data);
      }
    } catch (error) {
      console.error('Error loading driver vehicles:', error);
    }
  };

  // ========================================
  // CUSTOMER CRUD FUNCTIONS
  // ========================================

  const createCustomer = async (customerData: any) => {
    setLoading(true);
    try {
      // Check for valid token
      if (!authToken) {
        Alert.alert('Error', 'Session expired. Please log in again.');
        setCurrentScreen('login');
        setLoading(false);
        return;
      }
      // Use admin endpoint for customer creation
      // Ensure all required fields are present, including address_country
      const payload = {
        username: customerData.username,
        email: customerData.email,
        password: customerData.password,
        first_name: customerData.first_name,
        last_name: customerData.last_name,
        phone_number: customerData.phone_number,
        address: customerData.address || '',
        address_unit: customerData.address_unit || '',
        address_street: customerData.address_street || '',
        address_city: customerData.address_city || '',
        address_state: customerData.address_state || '',
        address_postal_code: customerData.address_postal_code || '',
        address_country: customerData.address_country || 'US',
        company_name: customerData.company_name || '',
        is_business: customerData.is_business || false,
        preferred_pickup_address: customerData.preferred_pickup_address || ''
      };

      const response = await makeAuthenticatedRequest('/api/customers/', {
        method: 'POST',
        body: JSON.stringify(payload)
      });

      if (response.status === 401) {
        Alert.alert('Session Expired', 'Your session has expired. Please log in again.');
        setAuthToken(null);
        setCurrentScreen('login');
        setLoading(false);
        return;
      }

      if (!response.ok) {
        let errorMessage = 'Failed to create customer';
        let backendDetails = '';
        try {
          const errorData = await response.json();
          // JWT error handling
          if (errorData.code === 'token_not_valid' || errorData.detail?.includes('token')) {
            Alert.alert('Session Expired', 'Your session has expired. Please log in again.');
            setAuthToken(null);
            setCurrentScreen('login');
            setLoading(false);
            return;
          }
          errorMessage = errorData.message || errorData.detail || JSON.stringify(errorData);
          backendDetails = JSON.stringify(errorData, null, 2);
        } catch (e) {
          // Try to get text response for 500 errors
          try {
            const text = await response.text();
            backendDetails = text;
            errorMessage = `HTTP ${response.status}: ${response.statusText}\n${text}`;
          } catch (e2) {
            errorMessage = `HTTP ${response.status}: ${response.statusText}`;
          }
        }
        // Show backend details in Alert if 500 error
        if (response.status === 500) {
          Alert.alert('Server Error', `HTTP 500: Internal Server Error\n${backendDetails}`);
        }
        throw new Error(errorMessage);
      }

      Alert.alert('Success', 'Customer created successfully!');
      setCrudMode('list');
      await loadCustomers();

      // Reset form
      setCustomerForm({
        username: '', email: '', password: '', first_name: '', last_name: '',
        phone_number: '', address: '', address_unit: '', address_street: '',
        address_city: '', address_state: '', address_postal_code: '',
        address_country: 'US',
        company_name: '', is_business: false,
        preferred_pickup_address: ''
      });

    } catch (error) {
      console.error('Error creating customer:', error);
      if (error instanceof Error) {
        Alert.alert('Error', error.message || 'Failed to create customer');
      } else {
        Alert.alert('Error', 'Failed to create customer');
      }
    } finally {
      setLoading(false);
    }
  };
  const updateCustomer = async (customerId: any, customerData: any) => {
    setLoading(true);
    try {
      const response = await makeAuthenticatedRequest(`/api/customers/${customerId}/`, {
        method: 'PATCH',
        body: JSON.stringify(customerData)
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Failed to update customer');
      }

      Alert.alert('Success', 'Customer updated successfully!');
      setCrudMode('list');
      loadCustomers();

    } catch (error) {
      console.error('Error updating customer:', error);
      if (error instanceof Error) {
        Alert.alert('Error', error.message || 'Failed to update customer');
      } else {
        Alert.alert('Error', 'Failed to update customer');
      }
    } finally {
      setLoading(false);
    }
  };

  const deleteCustomer = async (customerId: any) => {
    setLoading(true);
    try {
      const response = await makeAuthenticatedRequest(`/api/customers/${customerId}/`, {
        method: 'DELETE'
      });

      // DELETE returns 204 No Content on success
      if (!response.ok) {
        let errorMessage = 'Failed to delete customer';
        try {
          const errorData = await response.json();
          errorMessage = errorData.detail || errorData.message || errorMessage;
        } catch (e) {
          // If response has no JSON, use default message
        }
        throw new Error(errorMessage);
      }

      Alert.alert('Success', 'Customer deleted successfully!');
      setCrudMode('list');
      // Refresh the customer list
      await loadCustomers();

    } catch (error) {
      console.error('Error deleting customer:', error);
      Alert.alert('Error', (error as any).message || 'Failed to delete customer');
    } finally {
      setLoading(false);
    }
  };

  const getCustomerDeliveries = async (customerId: any) => {
    try {
      const response = await makeAuthenticatedRequest(`/api/customers/${customerId}/my_deliveries/`);
      if (response.ok) {
        const data = await response.json();
        return data.results || data;
      }
      return [];
    } catch (error) {
      console.error('Error loading customer deliveries:', error);
      return [];
    }
  };

  const requestDelivery = async () => {
    if (!deliveryForm.dropoff_location) {
      Alert.alert('Error', 'Please provide dropoff location');
      return;
    }

    setLoading(true);
    try {
      const response = await makeAuthenticatedRequest('/api/deliveries/request_delivery/', {
        method: 'POST',
        body: JSON.stringify(deliveryForm)
      });

      if (response.ok) {
        Alert.alert('Success', 'Delivery requested successfully!');
        setDeliveryForm({
          pickup_location: '', dropoff_location: '', item_description: '',
          same_pickup_as_customer: false, use_preferred_pickup: false
        });
        setCurrentScreen('dashboard');
        await loadData(); // Refresh data
      } else {
        const errorData = await response.json();
        Alert.alert('Error', JSON.stringify(errorData));
      }
    } catch (error) {
      Alert.alert('Error', 'Network error during delivery request');
    }
    setLoading(false);
  };

  // ========================================
  // DRIVER CRUD FUNCTIONS
  // ========================================

  const createDriver = async (driverData: any) => {
    setLoading(true);
    try {
      const response = await makeAuthenticatedRequest('/api/drivers/', {
        method: 'POST',
        body: JSON.stringify({
          name: `${driverData.first_name} ${driverData.last_name}`.trim(),
          phone_number: driverData.phone_number,
          license_number: driverData.license_number,
          active: driverData.active !== undefined ? driverData.active : true
        })
      });

      if (!response.ok) {
        let errorMessage = 'Failed to create driver';
        try {
          const errorData = await response.json();
          errorMessage = errorData.message || errorData.detail || JSON.stringify(errorData);
        } catch (e) {
          errorMessage = `HTTP ${response.status}: ${response.statusText}`;
        }
        throw new Error(errorMessage);
      }

      Alert.alert('Success', 'Driver created successfully!');
      setDriverCrudMode('list');
      await loadDrivers();

      // Reset form
      setDriverForm({
        username: '', email: '', password: '', first_name: '', last_name: '', phone_number: '',
        license_number: '', vehicle_license_plate: '', vehicle_make: '', vehicle_model: '',
        year: new Date().getFullYear(), vehicle_vin: '', vehicle_capacity: 1000
      });

    } catch (error) {
      console.error('Error creating driver:', error);
      Alert.alert('Error', (error as any).message || 'Failed to create driver');
    } finally {
      setLoading(false);
    }
  };

  const updateDriver = async (driverId: any, driverData: any) => {
    setLoading(true);
    try {
      const response = await makeAuthenticatedRequest(`/api/drivers/${driverId}/`, {
        method: 'PATCH',
        body: JSON.stringify(driverData)
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Failed to update driver');
      }

      Alert.alert('Success', 'Driver updated successfully!');
      setDriverCrudMode('list');
      loadDrivers();

    } catch (error) {
      console.error('Error updating driver:', error);
      Alert.alert('Error', (error as any).message || 'Failed to update driver');
    } finally {
      setLoading(false);
    }
  };

  const deleteDriver = async (driverId: any) => {
    setLoading(true);
    try {
      const response = await makeAuthenticatedRequest(`/api/drivers/${driverId}/`, {
        method: 'DELETE'
      });

      if (!response.ok) {
        let errorMessage = 'Failed to delete driver';
        try {
          const errorData = await response.json();
          errorMessage = errorData.detail || errorData.message || errorMessage;
        } catch (e) {
          // If response has no JSON, use default message
        }
        throw new Error(errorMessage);
      }

      Alert.alert('Success', 'Driver deleted successfully!');
      setDriverCrudMode('list');
      await loadDrivers();

    } catch (error) {
      console.error('Error deleting driver:', error);
      Alert.alert('Error', (error as any).message || 'Failed to delete driver');
    } finally {
      setLoading(false);
    }
  };

  const assignVehicleToDriver = async (driverId: any, vehicleId: any, assignedFrom: any = null) => {
    setLoading(true);
    try {
      const response = await makeAuthenticatedRequest(`/api/drivers/${driverId}/assign_vehicle/`, {
        method: 'POST',
        body: JSON.stringify({
          vehicle_id: vehicleId,
          assigned_from: assignedFrom
        })
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.message || 'Failed to assign vehicle');
      }

      const data = await response.json();
      Alert.alert('Success', data.message || 'Vehicle assigned successfully!');
      await loadDrivers();
      await loadDriverVehicles();

    } catch (error) {
      console.error('Error assigning vehicle:', error);
      Alert.alert('Error', (error as any).message || 'Failed to assign vehicle');
    } finally {
      setLoading(false);
    }
  };

  const loadAvailableVehicles = async () => {
    try {
      const response = await makeAuthenticatedRequest('/api/drivers/creation_data/');
      if (response.ok) {
        const data = await response.json();
        return data.available_vehicles || [];
      }
      return [];
    } catch (error) {
      console.error('Error loading available vehicles:', error);
      return [];
    }
  };

  // ========================================
  // VEHICLE CRUD FUNCTIONS
  // ========================================

  /* 
   * PRODUCTION NOTE: Vehicle Data Validation Requirements
   * 
   * For MVP phase, vehicle make/model/capacity are user-input fields.
   * For production implementation, these should be validated against:
   * 
   * 1. **Manufacturer Database**: Official vehicle manufacturer lists (Ford, Toyota, etc.)
   * 2. **Model Validation**: Year-specific model catalogs with accurate specifications
   * 3. **Capacity Verification**: Official manufacturer payload/cargo capacity specs
   * 4. **VIN Integration**: Vehicle Identification Number lookup for automatic data population
   * 5. **Third-party APIs**: 
   *    - NHTSA Vehicle API (US)
   *    - Auto manufacturers' official APIs
   *    - Commercial vehicle databases (Edmunds, KBB, etc.)
   * 
   * Benefits for production:
   * - Prevents data entry errors
   * - Ensures accurate capacity calculations for delivery assignments
   * - Regulatory compliance for commercial vehicles
   * - Insurance verification compatibility
   * - Fleet management accuracy
   * 
   * Current MVP allows manual entry for development/testing purposes only.
   */

  const createVehicle = async (vehicleData: any) => {
    setLoading(true);
    try {
      const response = await makeAuthenticatedRequest('/api/vehicles/', {
        method: 'POST',
        body: JSON.stringify({
          license_plate: vehicleData.license_plate,
          make: vehicleData.make,
          model: vehicleData.model,
          year: vehicleData.year,
          vin: vehicleData.vin,
          capacity: vehicleData.capacity,
          active: true
        })
      });

      if (response) {
        Alert.alert('Success', 'Vehicle created successfully!');
        setVehicleCrudMode('list');
        setVehicleForm({
          license_plate: '',
          make: '',
          model: '',
          year: new Date().getFullYear(),
          vin: '',
          capacity: 1000,
          capacity_unit: 'kg'
        });
        await loadVehicles();
      }

    } catch (error) {
      console.error('Error creating vehicle:', error);
      Alert.alert('Error', (error as any).message || 'Failed to create vehicle');
    } finally {
      setLoading(false);
    }
  };

  const updateVehicle = async (vehicleId: any, vehicleData: any) => {
    setLoading(true);
    try {
      const response = await makeAuthenticatedRequest(`/api/vehicles/${vehicleId}/`, {
        method: 'PUT',
        body: JSON.stringify({
          license_plate: vehicleData.license_plate,
          make: vehicleData.make,
          model: vehicleData.model,
          year: vehicleData.year,
          vin: vehicleData.vin,
          capacity: vehicleData.capacity,
          active: vehicleData.active !== undefined ? vehicleData.active : true
        })
      });

      if (response) {
        Alert.alert('Success', 'Vehicle updated successfully!');
        setVehicleCrudMode('list');
        await loadVehicles();
      }

    } catch (error) {
      console.error('Error updating vehicle:', error);
      Alert.alert('Error', (error as any).message || 'Failed to update vehicle');
    } finally {
      setLoading(false);
    }
  };

  const deleteVehicle = async (vehicleId: number) => {
    setLoading(true);
    try {
      await makeAuthenticatedRequest(`/api/vehicles/${vehicleId}/`, {
        method: 'DELETE'
      });

      Alert.alert('Success', 'Vehicle deleted successfully!');
      setVehicleCrudMode('list');
      await loadVehicles();

    } catch (error) {
      console.error('Error deleting vehicle:', error);
      if (error instanceof Error) {
        Alert.alert('Error', error.message || 'Failed to delete vehicle');
      } else {
        Alert.alert('Error', 'Failed to delete vehicle');
      }
    } finally {
      setLoading(false);
    }
  };

  // Add missing handler stubs at the top of App function if not already defined
  function handleCreateDriver() { }
  function handleEditDriver() { }
  function handleDeleteDriver() { }

  // Stub for DriverAdminList
  function DriverAdminList(props: any) {
    return (
      <View>
        <Text>DriverAdminList Component (stub)</Text>
      </View>
    );
  }

  // Stub for DriverForm
  function DriverForm(props: any) {
    return (
      <View>
        <Text>DriverForm Component (stub)</Text>
      </View>
    );
  }

  // Stub for submitDriverForm
  function submitDriverForm() {
    // TODO: Implement driver form submission logic
  }

  // ========================================
  // EFFECTS
  // ========================================

  useEffect(() => {
    checkBackend();
  }, []);

  useEffect(() => {
    if (authToken && currentScreen === 'dashboard') {
      loadData();
    }
  }, [authToken, currentScreen, userType]);

  // ========================================
  // RENDER FUNCTIONS

  // Admin Customers Screen
  if (currentScreen === 'admin_customers') {
    return <AdminCustomersScreen onBack={() => setCurrentScreen('dashboard')} customers={customers} loadCustomers={loadCustomers} />;
  }

  // Admin Vehicles Screen
  if (currentScreen === 'admin_vehicles') {
    return <AdminVehiclesScreen onBack={() => setCurrentScreen('dashboard')} />;
  }

  // Admin Deliveries Screen
  if (currentScreen === 'admin_deliveries') {
    return <AdminDeliveriesScreen onBack={() => setCurrentScreen('dashboard')} />;
  }

  // Delivery Request Screen
  if (currentScreen === 'delivery_request') {
    return <DeliveryRequestScreen onBack={() => setCurrentScreen('dashboard')} />;
  }

  // My Deliveries Screen
  if (currentScreen === 'my_deliveries') {
    return <MyDeliveriesScreen onBack={() => setCurrentScreen('dashboard')} />;
  }
  // ========================================

  // Loading Screen
  if (loading) {
    return (
      <View style={[styles.container, styles.center]}>
        <ActivityIndicator size="large" color="#0066CC" />
        <Text style={styles.loadingText}>Loading...</Text>
      </View>
    );
  }

  // Main Welcome Screen
  if (currentScreen === 'main') {
    return (
      <ScrollView style={styles.container}>
        <View style={styles.content}>
          <Text style={styles.title}>üöö DeliveryApp Mobile</Text>
          <Text style={styles.subtitle}>Complete Delivery Management System</Text>

          <View style={styles.statusContainer}>
            <Text style={styles.statusLabel}>Backend Status</Text>
            <Text style={styles.status}>{backendStatus}</Text>
            <Text style={styles.networkLabel}>Network: {currentNetwork}</Text>
          </View>

          <View style={styles.section}>
            <Text style={styles.sectionTitle}>üîê Authentication</Text>
            <View style={styles.buttonContainer}>
              <Button title="üîë Login" onPress={() => setCurrentScreen('login')} />
            </View>
          </View>

          <View style={styles.section}>
            <Text style={styles.sectionTitle}>üìù Registration</Text>
            <View style={styles.buttonContainer}>
              <Button title="üë§ Register as Customer" onPress={() => setCurrentScreen('customer_register')} />
            </View>
            <View style={styles.buttonContainer}>
              <Button title="üöö Register as Driver" onPress={() => setCurrentScreen('driver_register')} />
            </View>
          </View>

          <View style={styles.section}>
            <View style={styles.buttonContainer}>
              <Button title="üîÑ Check Backend" onPress={checkBackend} />
            </View>
          </View>
        </View>
      </ScrollView>
    );
  }

  // Login Screen
  if (currentScreen === 'login') {
    return (
      <ScrollView style={styles.container}>
        <View style={styles.content}>
          <Text style={styles.title}>üîë Login</Text>

          <TextInput
            style={styles.input}
            value={loginForm.username}
            onChangeText={(text) => setLoginForm({ ...loginForm, username: text })}
            placeholder="Username"
            autoCapitalize="none"
          />

          <TextInput
            style={styles.input}
            value={loginForm.password}
            onChangeText={(text) => setLoginForm({ ...loginForm, password: text })}
            placeholder="Password"
            secureTextEntry
          />

          <View style={styles.buttonContainer}>
            <Button title="Login" onPress={login} disabled={loading} />
          </View>

          <View style={styles.buttonContainer}>
            <Button title="Back" onPress={() => setCurrentScreen('main')} />
          </View>

          <View style={styles.section}>
            <Text style={styles.infoText}>
              Need an account? Go back and register as a customer or driver first.
            </Text>
          </View>
        </View>
      </ScrollView>
    );
  }

  // Customer Registration Screen - KEYBOARD FIXED!
  if (currentScreen === 'customer_register') {
    return (
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 60 : 0}
      >
        <ScrollView
          style={styles.container}
          contentContainerStyle={styles.scrollContent}
          keyboardShouldPersistTaps="handled"
          showsVerticalScrollIndicator={false}
        >
          <View style={styles.content}>
            <Text style={styles.title}>üë§ Customer Registration</Text>

            <Text style={styles.sectionTitle}>Account Information</Text>
            <TextInput
              style={styles.input}
              value={customerForm.username}
              onChangeText={(text) => setCustomerForm({ ...customerForm, username: text })}
              placeholder="Username *"
              autoCapitalize="none"
            />

            <TextInput
              style={styles.input}
              value={customerForm.email}
              onChangeText={(text) => setCustomerForm({ ...customerForm, email: text })}
              placeholder="Email *"
              keyboardType="email-address"
              autoCapitalize="none"
            />

            <TextInput
              style={styles.input}
              value={customerForm.password}
              onChangeText={(text) => setCustomerForm({ ...customerForm, password: text })}
              placeholder="Password *"
              secureTextEntry
            />

            <Text style={styles.sectionTitle}>Personal Information</Text>
            <TextInput
              style={styles.input}
              value={customerForm.first_name}
              onChangeText={(text) => setCustomerForm({ ...customerForm, first_name: text })}
              placeholder="First Name"
            />

            <TextInput
              style={styles.input}
              value={customerForm.last_name}
              onChangeText={(text) => setCustomerForm({ ...customerForm, last_name: text })}
              placeholder="Last Name"
            />

            <TextInput
              style={styles.input}
              value={customerForm.phone_number}
              onChangeText={(text) => setCustomerForm({ ...customerForm, phone_number: text })}
              placeholder="Phone Number"
              keyboardType="phone-pad"
            />

            <Text style={styles.sectionTitle}>üìç Address Information</Text>

            <TextInput
              style={styles.input}
              value={customerForm.address_unit}
              onChangeText={(text) => setCustomerForm({ ...customerForm, address_unit: text })}
              placeholder="Unit/Apartment (Optional)"
            />

            <TextInput
              style={styles.input}
              value={customerForm.address_street}
              onChangeText={(text) => setCustomerForm({ ...customerForm, address_street: text })}
              placeholder="Street Address"
            />

            <TextInput
              style={styles.input}
              value={customerForm.address_city}
              onChangeText={(text) => setCustomerForm({ ...customerForm, address_city: text })}
              placeholder="City"
            />

            <TextInput
              style={styles.input}
              value={customerForm.address_state}
              onChangeText={(text) => setCustomerForm({ ...customerForm, address_state: text })}
              placeholder="State/Province"
            />

            <TextInput
              style={styles.input}
              value={customerForm.address_postal_code}
              onChangeText={(text) => setCustomerForm({ ...customerForm, address_postal_code: text })}
              placeholder="Postal/ZIP Code"
            />

            <Text style={styles.sectionTitle}>Business Customer</Text>
            <View style={styles.switchContainer}>
              <Text style={styles.switchLabel}>Is Business Customer</Text>
              <Switch
                value={customerForm.is_business}
                onValueChange={(value) => setCustomerForm({ ...customerForm, is_business: value })}
              />
            </View>

            {customerForm.is_business && (
              <TextInput
                style={styles.input}
                value={customerForm.company_name}
                onChangeText={(text) => setCustomerForm({ ...customerForm, company_name: text })}
                placeholder="Company Name"
              />
            )}

            <TextInput
              style={[styles.input, styles.multilineInput]}
              value={customerForm.preferred_pickup_address}
              onChangeText={(text) => setCustomerForm({ ...customerForm, preferred_pickup_address: text })}
              placeholder="Preferred Pickup Address (Optional)"
              multiline
              numberOfLines={2}
            />

            <View style={styles.buttonContainer}>
              <Button title="Register Customer" onPress={registerCustomer} disabled={loading} />
            </View>

            <View style={styles.buttonContainer}>
              <Button title="Back" onPress={() => setCurrentScreen('main')} />
            </View>

            {/* Extra padding to ensure buttons are visible above keyboard */}
            <View style={styles.keyboardPadding} />
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    );
  }

  // Driver Registration Screen - KEYBOARD FIXED!
  if (currentScreen === 'driver_register') {
    return (
      <KeyboardAvoidingView
        style={styles.container}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        keyboardVerticalOffset={Platform.OS === 'ios' ? 60 : 0}
      >
        <ScrollView
          style={styles.container}
          contentContainerStyle={styles.scrollContent}
          keyboardShouldPersistTaps="handled"
          showsVerticalScrollIndicator={false}
        >
          <View style={styles.content}>
            <Text style={styles.title}>üöö Driver Registration</Text>

            <TextInput
              style={styles.input}
              value={driverForm.username}
              onChangeText={(text) => setDriverForm({ ...driverForm, username: text })}
              placeholder="Username *"
              autoCapitalize="none"
            />

            <TextInput
              style={styles.input}
              value={driverForm.email}
              onChangeText={(text) => setDriverForm({ ...driverForm, email: text })}
              placeholder="Email *"
              keyboardType="email-address"
              autoCapitalize="none"
            />

            <TextInput
              style={styles.input}
              value={driverForm.password}
              onChangeText={(text) => setDriverForm({ ...driverForm, password: text })}
              placeholder="Password *"
              secureTextEntry
            />

            <TextInput
              style={styles.input}
              value={driverForm.first_name}
              onChangeText={(text) => setDriverForm({ ...driverForm, first_name: text })}
              placeholder="First Name *"
              autoCapitalize="words"
            />

            <TextInput
              style={styles.input}
              value={driverForm.last_name}
              onChangeText={(text) => setDriverForm({ ...driverForm, last_name: text })}
              placeholder="Last Name *"
              autoCapitalize="words"
            />

            <TextInput
              style={styles.input}
              value={driverForm.phone_number}
              onChangeText={(text) => setDriverForm({ ...driverForm, phone_number: text })}
              placeholder="Phone Number *"
              keyboardType="phone-pad"
            />

            <TextInput
              style={styles.input}
              value={driverForm.license_number}
              onChangeText={(text) => setDriverForm({ ...driverForm, license_number: text })}
              placeholder="Driver License Number *"
            />

            <Text style={styles.sectionTitle}>Vehicle Information</Text>
            <TextInput
              style={styles.input}
              value={driverForm.vehicle_license_plate}
              onChangeText={(text) => setDriverForm({ ...driverForm, vehicle_license_plate: text.toUpperCase() })}
              placeholder="Vehicle License Plate *"
              autoCapitalize="characters"
            />

            <TextInput
              style={styles.input}
              value={driverForm.vehicle_make}
              onChangeText={(text) => setDriverForm({ ...driverForm, vehicle_make: text })}
              placeholder="Vehicle Make (e.g., Ford, Toyota) *"
            />

            <TextInput
              style={styles.input}
              value={driverForm.vehicle_model}
              onChangeText={(text) => setDriverForm({ ...driverForm, vehicle_model: text })}
              placeholder="Vehicle Model (e.g., Transit, Hiace) *"
            />

            <TextInput
              style={styles.input}
              value={driverForm.year ? driverForm.year.toString() : ''}
              onChangeText={(text) => {
                if (text === '') {
                  setDriverForm({ ...driverForm, year: new Date().getFullYear() });
                } else {
                  const year = parseInt(text);
                  if (!isNaN(year) && year >= 1900 && year <= 2100) {
                    setDriverForm({ ...driverForm, year });
                  }
                }
              }}
              placeholder="Vehicle Year (e.g., 2024) *"
              keyboardType="numeric"
              maxLength={4}
            />

            <TextInput
              style={styles.input}
              value={driverForm.vehicle_vin}
              onChangeText={(text) => setDriverForm({ ...driverForm, vehicle_vin: text.toUpperCase() })}
              placeholder="VIN (17 characters) *"
              autoCapitalize="characters"
              maxLength={17}
            />

            <TextInput
              style={styles.input}
              value={driverForm.vehicle_capacity.toString()}
              onChangeText={(text) => {
                const capacity = parseInt(text) || 1000;
                if (capacity >= 1 && capacity <= 50000) {
                  setDriverForm({ ...driverForm, vehicle_capacity: capacity });
                }
              }}
              placeholder="Vehicle Capacity (kg) *"
              keyboardType="numeric"
            />

            <View style={styles.buttonContainer}>
              <Button title="Register Driver & Vehicle" onPress={registerDriver} disabled={loading} />
            </View>

            <View style={styles.buttonContainer}>
              <Button title="Back" onPress={() => setCurrentScreen('main')} />
            </View>

            {/* Extra padding to ensure buttons are visible above keyboard */}
            <View style={styles.keyboardPadding} />
          </View>
        </ScrollView>
      </KeyboardAvoidingView>
    );
  }

  // Dashboard Screen (Post-Login)
  if (currentScreen === 'dashboard') {
    return (
      <ScrollView style={styles.container}>
        <View style={styles.content}>
          <Text style={styles.title}>üìä Dashboard</Text>
          <Text style={styles.subtitle}>Welcome, {typeof userType === 'string' ? userType.toUpperCase() : ''} User!</Text>

          <View style={styles.statusContainer}>
            <Text style={styles.statusLabel}>Status: Logged In</Text>
            <Text style={styles.networkLabel}>User Type: {userType}</Text>
          </View>

          {/* Customer Dashboard */}
          {userType === 'customer' && (
            <View style={styles.section}>
              <Text style={styles.sectionTitle}>üì¶ Customer Services</Text>
              <View style={styles.buttonContainer}>
                <Button title="üìã Request Delivery" onPress={() => setCurrentScreen('delivery_request')} />
              </View>
              <View style={styles.buttonContainer}>
                <Button title="üìã My Deliveries" onPress={() => setCurrentScreen('my_deliveries')} />
              </View>
            </View>
          )}

          {/* Admin Dashboard */}
          {/* Admin Dashboard (ScrollView only for dashboard, not CRUD screens) */}
          {userType === 'admin' && !adminScreen && (
            <ScrollView style={styles.container}>
              <View style={styles.content}>
                <Text style={styles.sectionTitle}>üõ†Ô∏è Admin Management</Text>
                <View style={styles.buttonContainer}>
                  <Button title="üë• Manage Customers" onPress={() => setCurrentScreen('admin_customers')} />
                </View>
                <View style={styles.buttonContainer}>
                  <Button title="üöö Manage Drivers" onPress={() => setCurrentScreen('admin_drivers')} />
                </View>
                <View style={styles.buttonContainer}>
                  <Button title="üöõ Manage Vehicles" onPress={() => setCurrentScreen('admin_vehicles')} />
                </View>
                <View style={styles.buttonContainer}>
                  <Button title="üì¶ Manage Deliveries" onPress={() => setCurrentScreen('admin_deliveries')} />
                </View>
                <View style={styles.buttonContainer}>
                  <Button title="üîó Driver Vehicles" onPress={async () => { await loadDriverVehicles(); setAdminScreen('driver_vehicles'); }} />
                </View>
                <View style={styles.buttonContainer}>
                  <Button title="üîÑ" onPress={loadData} />
                </View>
                <View style={styles.buttonContainer}>
                  <Button title="üö™ Logout" onPress={() => {
                    setAuthToken(null);
                    setUserType(null);
                    setCurrentScreen('main');
                  }} />
                </View>
              </View>
            </ScrollView>
          )}

          {/* Admin Drivers CRUD (no ScrollView) */}
          {userType === 'admin' && adminScreen === 'admin_drivers' && (
            <View style={styles.container}>
              <View style={styles.content}>
                {driverCrudMode === 'list' && (
                  <DriverAdminList
                    drivers={drivers}
                    onCreate={handleCreateDriver}
                    onEdit={handleEditDriver}
                    onDelete={handleDeleteDriver}
                    onBack={() => setAdminScreen(null)}
                  />
                )}
                {(driverCrudMode === 'create' || driverCrudMode === 'edit') && (
                  <DriverForm
                    form={driverFormState}
                    setForm={setDriverFormState}
                    onSubmit={submitDriverForm}
                    onCancel={() => setDriverCrudMode('list')}
                    isEdit={driverCrudMode === 'edit'}
                  />
                )}
              </View>
            </View>
          )}
        </View>
      </ScrollView>
    );
  }

  // Default/Fallback Screen
  return (
    <View style={styles.container}>
      <Text>Default/Fallback Screen</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f5f5f5',
  },
  content: {
    padding: 20,
  },
  center: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    textAlign: 'center',
    marginBottom: 10,
    color: '#333',
  },
  subtitle: {
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 20,
    color: '#666',
  },
  section: {
    marginVertical: 15,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
    color: '#333',
  },
  itemContainer: {
    padding: 15,
    backgroundColor: 'white',
    borderRadius: 8,
    marginBottom: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  itemTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 5,
    color: '#333',
  },
  statusContainer: {
    padding: 15,
    backgroundColor: 'white',
    borderRadius: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  statusLabel: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 5,
    color: '#333',
  },
  status: {
    fontSize: 14,
    fontWeight: 'bold',
    color: '#333',
  },
  networkLabel: {
    fontSize: 14,
    color: '#666',
    marginTop: 5,
  },
  loadingContainer: {
    alignItems: 'center',
    marginVertical: 20,
  },
  loadingText: {
    marginTop: 10,
    fontSize: 16,
    color: '#666',
  },
  buttonContainer: {
    marginVertical: 8,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    backgroundColor: '#f9f9f9',
    marginBottom: 10,
  },
  multilineInput: {
    minHeight: 80,
    textAlignVertical: 'top',
  },
  detailCard: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 15,
    marginBottom: 15,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  detailCardTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 15,
    color: '#333',
    borderBottomWidth: 1,
    borderBottomColor: '#eee',
    paddingBottom: 10,
  },
  emptyText: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
    fontStyle: 'italic',
    marginVertical: 20,
  },
  deliveryItem: {
    backgroundColor: '#f8f9fa',
    padding: 12,
    borderRadius: 8,
    marginBottom: 10,
    borderLeftWidth: 4,
    borderLeftColor: '#007AFF',
  },
  deliveryTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 5,
    color: '#333',
  },
  deliveryDetail: {
    fontSize: 14,
    color: '#666',
    marginBottom: 2,
  },
  infoText: {
    fontSize: 14,
    color: '#666',
    textAlign: 'center',
    fontStyle: 'italic',
    marginVertical: 10,
  },
  scrollContent: {
    flexGrow: 1,
    paddingBottom: 100,
  },
  switchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 15,
    marginBottom: 10,
  },
  switchLabel: {
    fontSize: 16,
    color: '#333',
    flex: 1,
  },
  keyboardPadding: {
    height: 200,
  },
  // ...add any other styles used in your JSX...
});